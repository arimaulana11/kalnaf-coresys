generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- ENUMS ---
enum ProductType {
  PHYSICAL
  SERVICE
  PARCEL
  DIGITAL
}

// --- MULTI-TENANCY & STORES ---

model tenants {
  id            String          @id @db.Uuid
  name          String          @db.VarChar(150)
  plan          String          @default("basic") @db.VarChar(50)
  is_active     Boolean?        @default(true)
  created_at    DateTime?       @default(now()) @db.Timestamp(6)
  updated_at    DateTime?       @updatedAt
  
  categories    categories[]
  products      products[]
  stores        stores[]
  tenant_addons tenant_addons[]
  transactions  transactions[]
  users         users[]
}

model stores {
  id              String            @id @db.Uuid
  tenant_id       String            @db.Uuid
  name            String            @db.VarChar(150)
  address         String?
  phone           String?           @db.VarChar(20)
  logo_url        String?
  receipt_header  String?
  receipt_footer  String?
  is_active       Boolean?          @default(true)
  created_at      DateTime          @default(now()) @db.Timestamp(6)
  updated_at      DateTime          @default(now()) @updatedAt
  
  inventory_stock inventory_stock[]
  transactions    transactions[]
  user_stores     user_stores[]
  tenants         tenants           @relation(fields: [tenant_id], references: [id], onDelete: Cascade)

  @@unique([tenant_id, name])
}

// --- PRODUCT & INVENTORY LOGIC ---

model products {
  id               Int                @id @default(autoincrement())
  tenant_id        String             @db.Uuid
  category_id      Int
  name             String             @db.VarChar(100)
  description      String?
  type             ProductType        @default(PHYSICAL)
  
  product_variants product_variants[]
  inventory_stock  inventory_stock[]  
  categories       categories         @relation(fields: [category_id, tenant_id], references: [id, tenant_id])
  tenants          tenants            @relation(fields: [tenant_id], references: [id], onDelete: Cascade)

  @@unique([id, tenant_id])
  @@index([tenant_id])
  @@index([category_id])
}

model product_variants {
  id                 Int                 @id @default(autoincrement())
  product_id         Int
  name               String              @db.VarChar(100) 
  sku                String?             @unique @db.VarChar(50)
  
  // LOGIKA MULTI-UOM (Grosir/Ecer)
  unit_name          String              @db.VarChar(20) 
  multiplier         Int                 @default(1)     
  is_base_unit       Boolean             @default(false) 
  
  price              Int                 
  
  products           products            @relation(fields: [product_id], references: [id], onDelete: Cascade)
  price_history      price_history[]
  transaction_items  transaction_items[]
  
  // Relasi PARCEL (Self-relation)
  as_component       product_components[] @relation("ComponentVariant")
  bundle_components  product_components[] @relation("ParentVariant")

  @@index([product_id])
}

model product_components {
  id                  Int              @id @default(autoincrement())
  parent_variant_id   Int              
  component_variant_id Int              
  qty                 Int              
  
  parent_variant      product_variants @relation("ParentVariant", fields: [parent_variant_id], references: [id], onDelete: Cascade)
  component_variant   product_variants @relation("ComponentVariant", fields: [component_variant_id], references: [id])
}

model inventory_stock {
  id                 Int              @id @default(autoincrement())
  store_id           String           @db.Uuid
  product_id         Int              
  stock_qty          BigInt           @default(0) 
  
  products           products         @relation(fields: [product_id], references: [id], onDelete: Cascade)
  stores             stores           @relation(fields: [store_id], references: [id], onDelete: Cascade)

  @@unique([store_id, product_id])
}

// --- TRANSACTIONS ---

model transactions {
  id                Int                 @id @default(autoincrement())
  tenant_id         String              @db.Uuid
  store_id          String              @db.Uuid
  created_by        String              @db.Uuid
  customer_name     String?             @db.VarChar(100)
  total_amount      Int
  transaction_date  DateTime            @default(now()) @db.Timestamp(6)
  
  transaction_items transaction_items[]
  tenants           tenants             @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
  stores            stores              @relation(fields: [store_id], references: [id])
  users             users               @relation(fields: [created_by], references: [id])

  @@index([created_by])
  @@index([tenant_id, store_id])
}

model transaction_items {
  id                 Int              @id @default(autoincrement())
  transaction_id     Int
  product_variant_id Int
  qty                Int              
  unit_price         Int
  subtotal           Int
  
  product_variants   product_variants @relation(fields: [product_variant_id], references: [id])
  transactions       transactions     @relation(fields: [transaction_id], references: [id], onDelete: Cascade)

  @@index([transaction_id])
  @@index([product_variant_id])
}

// --- USER & AUTH ---

model users {
  id            String          @id @db.Uuid
  tenant_id     String          @db.Uuid
  name          String?         @db.VarChar(150)
  email         String          @unique @db.VarChar(150)
  password_hash String
  role          String          @default("owner") @db.VarChar(50)
  is_active     Boolean?        @default(true)
  last_login_at DateTime?       @db.Timestamp(6)
  created_at    DateTime?       @default(now()) @db.Timestamp(6)
  updated_at    DateTime?
  
  refresh_tokens refresh_tokens[]
  transactions   transactions[]
  user_stores    user_stores[]
  tenants        tenants         @relation(fields: [tenant_id], references: [id], onDelete: Cascade)

  @@index([tenant_id])
}

model user_stores {
  user_id    String    @db.Uuid
  store_id   String    @db.Uuid
  status     String    @default("active") @db.VarChar(20)
  created_at DateTime  @default(now()) @db.Timestamp(6)
  updated_at DateTime  @default(now()) @updatedAt
  deleted_at DateTime? @db.Timestamp(6)
  
  stores     stores    @relation(fields: [store_id], references: [id], onDelete: Cascade)
  users      users     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@id([user_id, store_id])
}

model refresh_tokens {
  id          String   @id @db.Uuid
  user_id     String   @db.Uuid
  token_hash  String   @unique
  expires_at  DateTime @db.Timestamp(6)
  revoked     Boolean? @default(false)
  created_at  DateTime? @default(now()) @db.Timestamp(6)
  
  users       users    @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([token_hash])
  @@index([user_id])
}

// --- ADDONS & OTHERS ---

model addons {
  id            String          @id @db.Uuid
  code          String          @unique @db.VarChar(50)
  name          String          @db.VarChar(150)
  description   String?
  price_monthly Int
  created_at    DateTime?       @default(now()) @db.Timestamp(6)
  tenant_addons tenant_addons[]
}

model tenant_addons {
  id           String    @id @db.Uuid
  tenant_id    String    @db.Uuid
  addon_id     String    @db.Uuid
  status       String    @default("active") @db.VarChar(20)
  activated_at DateTime  @default(now()) @db.Timestamp(6)
  expires_at   DateTime? @db.Timestamp(6)
  auto_renew   Boolean   @default(true)
  
  addons       addons    @relation(fields: [addon_id], references: [id], onDelete: Cascade)
  tenants      tenants   @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
}

model categories {
  id          Int        @id @default(autoincrement())
  tenant_id   String     @db.Uuid
  name        String     @db.VarChar(100)
  description String?
  
  tenants     tenants    @relation(fields: [tenant_id], references: [id], onDelete: Cascade)
  products    products[]

  @@unique([id, tenant_id])
}

model price_history {
  id                 Int              @id @default(autoincrement())
  product_variant_id Int
  old_price          Int?
  new_price          Int
  change_date        DateTime?        @default(now()) @db.Timestamp(6)
  notes              String?
  
  product_variants   product_variants @relation(fields: [product_variant_id], references: [id], onDelete: Cascade)
}